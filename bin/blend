#!/usr/bin/env ruby

# Copyright (c) 2008 Chris Griego
#           (c) 2008 Blake Elshire
# 
# Blender is freely distributable under the terms of an MIT-style license.
# For details, see http://www.opensource.org/licenses/mit-license.php

require 'yaml'
require 'optparse'
require 'rdoc/usage'
require 'ostruct'
require 'base64'
require 'benchmark'
require 'mime/types'
require 'find'

# TODO Move class to lib so other tools could potentially reuse it
class Blender
  VERSION = '0.7.1'
  
  attr_reader :options
  
  def initialize(arguments, stdin)
    @arguments   = !arguments.include?('--') ? arguments : arguments[0...arguments.index('--')]
    @passthrough = !arguments.include?('--') ? ''        : arguments[arguments.index('--')+1..-1]
    
    # Set defaults
    @options = OpenStruct.new
    @options.blendfile = 'blender.yaml'
    @options.png       = false
    @options.data      = false
    @options.force     = false
    @options.generate  = false
  end
  
  def blend
    if parsed_options?
      if @options.generate
        create_blendfile
      end
      
      elapsed = Benchmark.realtime do
        unless File.exists? @options.blendfile
          puts "Couldn't find '#{@options.blendfile}'"
          exit 1
        end
        
        blender = YAML::load_file @options.blendfile
        
        Dir.chdir(File.dirname(@options.blendfile))
        
        blender.each do |output_name, inputs|
          output_new = false
          
          # Checks the type flag and if the current file meets the type requirements continues
          if output_name.match "." + @options.file_type.to_s
            file_type = output_name.match(/\.css/) ? "css" : "js"
            
            # Checks if output file exists and checks the mtimes of the source files to the output file if new creates a new file
            if File.exists? output_name
              inputs.each do |i|
                if File.mtime(i) > File.mtime(output_name)
                  output_new = true
                  break
                end
              end
              
              if output_new || @options.force
                create_output(output_name, inputs, file_type)
              else
                puts "Skipping: #{output_name}"
              end
            else
              create_output(output_name, inputs, file_type)
            end
          end
        end
      end
      
      puts sprintf("%.5f", elapsed) + " seconds"
    end
  end
  
  protected
  
  def parsed_options?
    opts = OptionParser.new
    
    opts.on('-v', '--version') { output_version ; exit 0 }
    opts.on('-h', '--help')    { output_help }
    
    opts.on('-f FILE', '--file FILE', String, "Use given Blendfile") do |blendfile|
      @options.blendfile = blendfile
    end
    
    opts.on("-t [TYPE]", "--type [TYPE]", [:css, :js], "Select file type to minify (css, js)") do |t|
      @options.file_type = t
    end
    
    opts.on("-d", "--data", String, "Change url(image.ext) to url(data:) in css files") { @options.data = true }
    opts.on("--force", String, "Force minification when source files aren't newer than output files") { @options.force = true }
    opts.on("--generate", String, "Generate a blendfile") { @options.generate = true }
    opts.parse!(@arguments) rescue return false
    
    true
  end
  
  def create_blendfile
    if File.exists?(@options.blendfile) && !@options.force
      puts "'#{@options.blendfile}' already exists"
      exit 1
    end
    
    blend_files = Hash.new
    
    Find.find(Dir.getwd) do |f|
      f.gsub!(Dir.getwd.to_s+"/", "")
      if File.extname(f) == ".css"
        file = f.split(".css")
        min_file = file[0] + "-min.css"
        blend_files[f] = [min_file]
      end
      
      if File.extname(f) == ".js"
        file = f.split(".js")
        min_file = file[0] + "-min.js"
        blend_files[f] = [min_file]
      end
      
      Find.prune if File.basename(f).index('.') == 0
    end
    
    File.open(@options.blendfile, 'w') { |f| YAML.dump(blend_files, f) }
    
    exit 0
  end
  
  # TODO Change to work with directory hashes (css/: [ colors.css, layout.css ])
  def create_output(output_name, inputs, type)
    File.open(output_name, 'w') do |output_file|
      output = ''
      
      inputs.each do |i|
        output << IO.read(i)
      end
      
      # Compress
      real_file = File.symlink?(__FILE__) ? File.readlink(__FILE__) : __FILE__
      
      IO.popen("java -jar #{File.dirname(real_file)}/../lib/yui/yuicompressor.jar #{@passthrough} --type #{type}", mode="r+") do |io|
        io.write output
        io.close_write
        
        output = io.read
        
        if File.extname(output_name) == ".css"
          output.gsub! ' and(', ' and (' # Workaround for YUI Compressor Bug #1938329
          output.gsub! '/**/;}', '/**/}' # Workaround for YUI Compressor Bug #1961175
          
          if @options.data
            output = output.gsub(/url\(['"]?([^?']+)['"]+\)/im) do
              uri = $1
              mime_type = ''
              
              # Make the URI absolute instead of relative. TODO Seems kinda hacky is there a better way?
              uri.gsub! "../", ""
              
              # Figure out the mime type.
              mime_type = MIME::Types.type_for(uri)
              
              url_contents = make_data_uri(IO.read(uri), mime_type[0])
              
              %Q!url("#{url_contents}")!
            end
          end
        end
        
        output_file << output
      end
    end
    
    puts output_name
  end
  
  def make_data_uri(content, content_type)
    outuri   = 'data:' + content_type + ';base64'
    content  = Base64.encode64(content)
    outuri  += ",#{content}"
    
    outuri.gsub("\n", '')
  end
  
  def output_version
    puts "#{File.basename(__FILE__)} version #{VERSION}"
  end
  
  def output_help
    output_version
    RDoc::usage() #exits app
  end
end

# Create and run the application
blender = Blender.new(ARGV, STDIN)
blender.blend
